# Issue Task PR Automation
#
# This workflow automates the creation of task branches, task files, and PRs when
# issues are assigned to the configured bot user.
#
# Required Permissions (configured below):
#   - contents: write (for creating branches and files)
#   - pull-requests: write (for creating PRs and adding labels)
#   - issues: write (for posting comments)
#
# Recommended Setup:
#   - Add a repository secret named TASK_BOT_USERNAME with the bot's GitHub username
#   - This allows the bot username to be configured without modifying the workflow
#   - If not set, the workflow will fall back to the user triggering the workflow

name: Issue Task PR Automation

on:
  issues:
    types:
      - assigned
  workflow_dispatch:
    inputs:
      title:
        description: Issue title for Codex to create
        required: true
        type: string
      body:
        description: Issue body
        required: false
        type: string
      labels:
        description: Comma-separated labels
        required: false
        type: string
      bot_username:
        description: Bot username (optional, overrides secret)
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  handle-issue-assignment:
    if: github.event_name == 'issues'
    name: Handle assigned issues
    runs-on: ubuntu-latest
    env:
      TASK_BOT_USERNAME: ${{ secrets.TASK_BOT_USERNAME }}
      WORKFLOW_INPUT_BOT_USERNAME: ${{ github.event.inputs.bot_username }}
    steps:
      - name: Prepare task branch and PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { core, context, github } = require('@actions/github-script');
            
            // Resolve BOT_USERNAME with precedence: workflow input -> secret -> GITHUB_ACTOR
            const BOT_USERNAME = process.env.WORKFLOW_INPUT_BOT_USERNAME || process.env.TASK_BOT_USERNAME || context.actor;
            
            core.info(`Using BOT_USERNAME: ${BOT_USERNAME}`);

            const assignedUser = context.payload.assignee;
            if (!assignedUser || assignedUser.login !== BOT_USERNAME) {
              core.info('Issue not assigned to the configured bot user. Skipping.');
              return;
            }

            const { owner, repo } = context.repo;
            const issue = context.payload.issue;
            const repository = context.payload.repository;
            const defaultBranch = repository.default_branch;
            const issueNumber = issue.number;

            // Retry utility with exponential backoff
            const retryWithBackoff = async (fn, retries = 3, delays = [500, 1000, 2000]) => {
              for (let attempt = 0; attempt < retries; attempt++) {
                try {
                  return await fn();
                } catch (error) {
                  // Treat 409 conflicts as success (already exists)
                  if (error.status === 409) {
                    core.info('Resource already exists (409 conflict), treating as success.');
                    return null;
                  }
                  
                  if (attempt === retries - 1) {
                    throw error;
                  }
                  
                  const delay = delays[attempt] || delays[delays.length - 1];
                  core.info(`Attempt ${attempt + 1} failed, retrying in ${delay}ms...`);
                  await new Promise(resolve => setTimeout(resolve, delay));
                }
              }
            };

            const slugFromTitle = (title) => {
              const base = title
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, '')
                .slice(0, 40);
              return base || `issue-${issueNumber}`;
            };

            const slug = slugFromTitle(issue.title);
            const branchName = `task/${issueNumber}-${slug}`;
            const filePath = `tasks/${issueNumber}-${slug}.md`;
            
            core.info(`Processing issue #${issueNumber}: ${issue.title}`);
            core.info(`Branch: ${branchName}`);
            core.info(`File: ${filePath}`);

            const ensureBranch = async () => {
              const getRefName = `heads/${branchName}`;
              const createRefName = `refs/heads/${branchName}`;
              
              try {
                await github.rest.git.getRef({ owner, repo, ref: getRefName });
                core.info(`Branch ${branchName} already exists.`);
              } catch (error) {
                if (error.status !== 404) throw error;
                
                core.info(`Branch does not exist, creating from ${defaultBranch}...`);
                const baseRef = await github.rest.git.getRef({ 
                  owner, 
                  repo, 
                  ref: `heads/${defaultBranch}` 
                });
                
                await retryWithBackoff(async () => {
                  return await github.rest.git.createRef({
                    owner,
                    repo,
                    ref: createRefName,
                    sha: baseRef.data.object.sha,
                  });
                });
                
                core.info(`Created branch ${branchName} from ${defaultBranch}.`);
              }
            };

            const upsertTaskFile = async () => {
              // Sanitize title for YAML frontmatter (escape quotes and backslashes)
              const safeTitle = issue.title
                .replace(/\\/g, '\\\\')
                .replace(/"/g, '\\"')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '');
              
              const content = `---\nissue: #${issueNumber}\ntitle: "${safeTitle}"\nassignee: @${BOT_USERNAME}\nbranch: ${branchName}\n---\n\n## Checklist\n\n- [ ] Review issue requirements\n- [ ] Implement solution\n- [ ] Open pull request\n- [ ] Notify repository owner\n`;
              const encodedContent = Buffer.from(content, 'utf8').toString('base64');

              let currentSha;
              try {
                const existing = await retryWithBackoff(async () => {
                  return await github.rest.repos.getContent({
                    owner,
                    repo,
                    path: filePath,
                    ref: branchName,
                  });
                });
                
                if (existing && !Array.isArray(existing.data)) {
                  currentSha = existing.data.sha;
                }
              } catch (error) {
                if (error.status !== 404) throw error;
              }

              core.info(`Upserting task file ${filePath}...`);
              await retryWithBackoff(async () => {
                return await github.rest.repos.createOrUpdateFileContents({
                  owner,
                  repo,
                  path: filePath,
                  message: `chore: track task #${issueNumber}`,
                  content: encodedContent,
                  branch: branchName,
                  sha: currentSha,
                });
              });
              
              core.info(`Updated ${filePath} on ${branchName}.`);
            };

            const ensurePullRequest = async () => {
              const head = `${owner}:${branchName}`;
              const existing = await github.rest.pulls.list({
                owner,
                repo,
                head,
                base: defaultBranch,
                state: 'open',
              });

              if (existing.data.length > 0) {
                core.info(`Reusing existing PR ${existing.data[0].html_url}.`);
                return existing.data[0];
              }

              const title = `task: #${issueNumber} ${issue.title}`.substring(0, 250);
              const body = `Automated task preparation for #${issueNumber}.\n\n- Issue: #${issueNumber}\n- Assignee: @${BOT_USERNAME}\n- Branch: \`${branchName}\``;

              core.info(`Creating pull request from ${branchName} to ${defaultBranch}...`);
              const pr = await retryWithBackoff(async () => {
                return await github.rest.pulls.create({
                  owner,
                  repo,
                  title,
                  head: branchName,
                  base: defaultBranch,
                  body,
                });
              });
              
              if (!pr) {
                throw new Error('Failed to create pull request');
              }
              
              core.info(`Created PR ${pr.data.html_url}.`);
              
              // Add automation:task label to PR
              try {
                // First, ensure the label exists
                try {
                  await github.rest.issues.getLabel({
                    owner,
                    repo,
                    name: 'automation:task',
                  });
                } catch (error) {
                  if (error.status === 404) {
                    core.info('Creating automation:task label...');
                    await github.rest.issues.createLabel({
                      owner,
                      repo,
                      name: 'automation:task',
                      color: '0e8a16',
                      description: 'Automated task PRs',
                    });
                  }
                }
                
                // Add label to PR
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: pr.data.number,
                  labels: ['automation:task'],
                });
                core.info('Added automation:task label to PR.');
              } catch (error) {
                core.warning(`Failed to add label: ${error.message}`);
              }
              
              return pr.data;
            };

            const ensureIssueComment = async (prUrl) => {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number: issueNumber,
              });

              // Check for duplicate by searching for PR URL or branch name in comments
              const alreadyCommented = comments.some((comment) => {
                const body = comment.body || '';
                return body.includes(prUrl) || body.includes(branchName);
              });

              if (alreadyCommented) {
                core.info('Issue already has automation comment with PR URL or branch name.');
                return;
              }

              const body = `🤖 **Automation update:** opened ${prUrl} from branch \`${branchName}\`.\n\nThe task file lives at \`${filePath}\`.`;
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body,
              });
              core.info('Posted comment linking to PR.');
            };

            try {
              await ensureBranch();
              await upsertTaskFile();
              const pr = await ensurePullRequest();
              await ensureIssueComment(pr.html_url);

              core.info('✅ Issue assignment processing complete.');
            } catch (error) {
              core.error(`Failed to process issue assignment: ${error.message}`);
              core.error(`Stack trace: ${error.stack}`);
              throw error;
            }

  create-issue:
    if: github.event_name == 'workflow_dispatch'
    name: Create issue on demand
    runs-on: ubuntu-latest
    outputs:
      issue-number: ${{ steps.create.outputs.result }}
    steps:
      - id: create
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const { core, context, github } = require('@actions/github-script');
            const title = core.getInput('title', { required: true });
            const body = core.getInput('body') || '';
            const labelsInput = core.getInput('labels') || '';
            const labels = labelsInput
              .split(',')
              .map((label) => label.trim())
              .filter((label) => label.length > 0);

            const { owner, repo } = context.repo;
            const issue = await github.rest.issues.create({
              owner,
              repo,
              title,
              body,
              labels,
            });

            core.info(`Created issue #${issue.data.number}.`);
            return issue.data.number.toString();

      - name: Log issue number
        run: echo "Created issue #${{ steps.create.outputs.result }}"
