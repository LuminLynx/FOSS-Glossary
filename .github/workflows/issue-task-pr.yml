# .github/workflows/issue-tasks.yml

name: 'Issue Task Automation'

on:
  issues:
<<<<<<< HEAD
    types:
      - assigned
      - labeled
=======
    types: [assigned]
>>>>>>> origin/main
  workflow_dispatch:
    inputs:
      issueNumber:
        description: 'Issue number to process'
        required: true
      taskTitle:
        description: 'Title for the task'
        required: true
      taskBody:
        description: 'Body content for the task'
        required: false
<<<<<<< HEAD
        type: string
      labels:
        description: Comma-separated labels (e.g., enhancement, bug)
        required: false
        type: string
      notify_slack:
        description: Send Slack notification
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  handle-issue-assignment:
    if: github.event_name == 'issues'
    name: Handle assigned issues
    runs-on: ubuntu-latest
    outputs:
      pr-url: ${{ steps.process.outputs.pr-url }}
      branch-name: ${{ steps.process.outputs.branch-name }}
      success: ${{ steps.process.outputs.success }}
    steps:
      - id: process
        name: Prepare task branch and PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const BOT_USERNAME = process.env.BOT_USERNAME || 'my-codex-bot';
            const TRIGGER_LABELS = (process.env.TRIGGER_LABELS || 'codex,ready-for-codex').split(',').map(l => l.trim().toLowerCase());
            const { core, context, github } = require('@actions/github-script');

            // Enhanced assignee and label handling
            const issue = context.payload.issue;
            const assignees = issue.assignees || [];
            const labels = issue.labels || [];
            
            const assignedToBot = assignees.some(a => a.login === BOT_USERNAME);
            const hasTriggerLabel = labels.some(l => TRIGGER_LABELS.includes(l.name.toLowerCase()));
            
            if (!assignedToBot && !hasTriggerLabel) {
              core.info(`Issue not assigned to bot (${BOT_USERNAME}) and no trigger label found. Skipping.`);
              core.setOutput('success', 'false');
              return;
            }
            
            core.info(`Processing issue #${issue.number} - Assigned to bot: ${assignedToBot}, Has trigger label: ${hasTriggerLabel}`);

            const { owner, repo } = context.repo;
            const repository = context.payload.repository;
            const defaultBranch = repository.default_branch;
            const issueNumber = issue.number;

            // Generate unique timestamp for conflict prevention
            const timestamp = Date.now();
            
            const slugFromTitle = (title) => {
              const base = title
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, '')
                .slice(0, 35);
              return base || `issue-${issueNumber}`;
            };

            const slug = slugFromTitle(issue.title);
            const branchName = `task/${issueNumber}-${slug}-${timestamp}`;
            const filePath = `tasks/${issueNumber}/${slug}-${timestamp}.md`;
            
            core.info(`Branch: ${branchName}, File: ${filePath}`);

            // Retry mechanism for API calls with exponential backoff
            const retryWithBackoff = async (fn, maxRetries = 3, baseDelay = 1000) => {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  return await fn();
                } catch (error) {
                  const isRetryable = error.status >= 500 || error.status === 429 || error.code === 'ECONNRESET';
                  if (attempt === maxRetries || !isRetryable) {
                    core.error(`Failed after ${attempt} attempts: ${error.message}`);
                    throw error;
                  }
                  const delay = baseDelay * Math.pow(2, attempt - 1);
                  core.warning(`Attempt ${attempt} failed: ${error.message}. Retrying in ${delay}ms...`);
                  await new Promise(resolve => setTimeout(resolve, delay));
                }
              }
            };

            const ensureBranch = async () => {
              const refName = `heads/${branchName}`;
              return retryWithBackoff(async () => {
                try {
                  await github.rest.git.getRef({ owner, repo, ref: refName });
                  core.info(`Branch ${branchName} already exists.`);
                } catch (error) {
                  if (error.status !== 404) throw error;
                  const baseRef = await github.rest.git.getRef({ owner, repo, ref: `heads/${defaultBranch}` });
                  await github.rest.git.createRef({
                    owner,
                    repo,
                    ref: `refs/${refName}`,
                    sha: baseRef.data.object.sha,
                  });
                  core.info(`âœ… Created branch ${branchName} from ${defaultBranch}.`);
                }
              });
            };

            const upsertTaskFile = async () => {
              return retryWithBackoff(async () => {
                const safeTitle = issue.title.replace(/"/g, '\\"');
                const createdAt = new Date().toISOString();
                const content = `---\nissue: #${issueNumber}\ntitle: "${safeTitle}"\nassignee: @${BOT_USERNAME}\nbranch: ${branchName}\ncreated: ${createdAt}\ntimestamp: ${timestamp}\n---\n\n## Checklist\n\n- [ ] Review issue requirements\n- [ ] Implement solution\n- [ ] Open pull request\n- [ ] Notify repository owner\n\n## Issue Details\n\n${issue.body || 'No description provided.'}\n`;
                const encodedContent = Buffer.from(content, 'utf8').toString('base64');

                let currentSha;
                try {
                  const existing = await github.rest.repos.getContent({
                    owner,
                    repo,
                    path: filePath,
                    ref: branchName,
                  });
                  if (!Array.isArray(existing.data)) {
                    currentSha = existing.data.sha;
                    core.info(`Task file already exists, updating...`);
                  }
                } catch (error) {
                  if (error.status !== 404) throw error;
                  core.info(`Creating new task file...`);
                }

                await github.rest.repos.createOrUpdateFileContents({
                  owner,
                  repo,
                  path: filePath,
                  message: `chore: track task #${issueNumber}`,
                  content: encodedContent,
                  branch: branchName,
                  sha: currentSha,
                });
                core.info(`âœ… Updated ${filePath} on ${branchName}.`);
              });
            };

            const ensurePullRequest = async () => {
              return retryWithBackoff(async () => {
                const head = `${owner}:${branchName}`;
                const existing = await github.rest.pulls.list({
                  owner,
                  repo,
                  head,
                  base: defaultBranch,
                  state: 'open',
                });

                if (existing.data.length > 0) {
                  core.info(`â™»ï¸  Reusing existing PR ${existing.data[0].html_url}.`);
                  return existing.data[0];
                }

                const title = `task: #${issueNumber} ${issue.title}`.substring(0, 250);
                const body = [
                  '## Automated Task Preparation',
                  '',
                  `**Issue:** #${issueNumber}`,
                  `**Assignee:** @${BOT_USERNAME}`,
                  `**Branch:** \`${branchName}\``,
                  `**Task File:** \`${filePath}\``,
                  `**Created:** ${new Date().toISOString()}`,
                  '',
                  '### Context',
                  issue.body || 'No description provided.',
                  '',
                  '### Checklist',
                  '- [ ] Review issue requirements',
                  '- [ ] Implement solution',
                  '- [ ] Run tests and validation',
                  '- [ ] Update documentation if needed',
                  '',
                  '---',
                  '_This PR was created automatically by the Issue Task PR Automation workflow._'
                ].join('\n');

                const pr = await github.rest.pulls.create({
                  owner,
                  repo,
                  title,
                  head: branchName,
                  base: defaultBranch,
                  body,
                });
                core.info(`âœ… Created PR ${pr.data.html_url}.`);
                return pr.data;
              });
            };

            const ensureIssueComment = async (prUrl) => {
              return retryWithBackoff(async () => {
                const comments = await github.paginate(github.rest.issues.listComments, {
                  owner,
                  repo,
                  issue_number: issueNumber,
                });

                const alreadyCommented = comments.some(
                  (comment) => comment.user?.login === BOT_USERNAME && comment.body.includes(prUrl)
                );

                if (alreadyCommented) {
                  core.info('â„¹ï¸  Issue already has automation comment.');
                  return;
                }

                const body = [
                  'ðŸ¤– **Automation Update**',
                  '',
                  `Opened ${prUrl} from branch \`${branchName}\`.`,
                  '',
                  `**Task file:** \`${filePath}\``,
                  `**Timestamp:** ${timestamp}`,
                  '',
                  'The task file contains the checklist and details for this issue. Progress will be tracked in the pull request.'
                ].join('\n');
                
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  body,
                });
                core.info('âœ… Posted comment linking to PR.');
              });
            };

            try {
              core.startGroup('Creating branch');
              await ensureBranch();
              core.endGroup();
              
              core.startGroup('Creating/updating task file');
              await upsertTaskFile();
              core.endGroup();
              
              core.startGroup('Creating/updating pull request');
              const pr = await ensurePullRequest();
              core.endGroup();
              
              core.startGroup('Posting issue comment');
              await ensureIssueComment(pr.html_url);
              core.endGroup();
              
              core.setOutput('pr-url', pr.html_url);
              core.setOutput('branch-name', branchName);
              core.setOutput('success', 'true');
              
              core.info('âœ… Issue assignment processing complete.');
              core.summary
                .addHeading('âœ… Task Automation Successful')
                .addRaw(`**Issue:** #${issueNumber}`)
                .addRaw(`\n**PR:** ${pr.html_url}`)
                .addRaw(`\n**Branch:** \`${branchName}\``)
                .addRaw(`\n**Task File:** \`${filePath}\``)
                .write();
            } catch (error) {
              core.setFailed(`Task automation failed: ${error.message}`);
              core.setOutput('success', 'false');
              core.summary
                .addHeading('âŒ Task Automation Failed')
                .addRaw(`**Issue:** #${issueNumber}`)
                .addRaw(`\n**Error:** ${error.message}`)
                .addRaw(`\n**Stack:** \`${error.stack}\``)
                .write();
              throw error;
            }
        env:
          BOT_USERNAME: ${{ vars.CODEX_BOT_LOGIN || 'my-codex-bot' }}
          TRIGGER_LABELS: ${{ vars.TRIGGER_LABELS || 'codex,ready-for-codex' }}

      - name: Send notification
        if: always() && vars.SLACK_WEBHOOK_URL != ''
        uses: actions/github-script@v7
        with:
          script: |
            const { core } = require('@actions/github-script');
            const success = '${{ steps.process.outputs.success }}' === 'true';
            const prUrl = '${{ steps.process.outputs.pr-url }}';
            const branchName = '${{ steps.process.outputs.branch-name }}';
            const issueNumber = context.payload.issue.number;
            
            const webhookUrl = process.env.SLACK_WEBHOOK_URL;
            if (!webhookUrl) {
              core.info('SLACK_WEBHOOK_URL not configured, skipping notification');
              return;
            }
            
            const emoji = success ? 'âœ…' : 'âŒ';
            const status = success ? 'Success' : 'Failed';
            const color = success ? 'good' : 'danger';
            
            const payload = {
              attachments: [{
                color: color,
                title: `${emoji} Issue Task PR Automation - ${status}`,
                fields: [
                  { title: 'Issue', value: `#${issueNumber}`, short: true },
                  { title: 'Repository', value: context.repo.owner + '/' + context.repo.repo, short: true }
                ],
                footer: 'GitHub Actions',
                ts: Math.floor(Date.now() / 1000)
              }]
            };
            
            if (success && prUrl) {
              payload.attachments[0].fields.push(
                { title: 'PR', value: prUrl, short: false },
                { title: 'Branch', value: branchName, short: true }
              );
            }
            
            try {
              const https = require('https');
              const data = JSON.stringify(payload);
              
              const options = {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Content-Length': data.length
                }
              };
              
              await new Promise((resolve, reject) => {
                const req = https.request(webhookUrl, options, (res) => {
                  res.on('data', () => {});
                  res.on('end', () => resolve());
                });
                req.on('error', reject);
                req.write(data);
                req.end();
              });
              
              core.info('âœ… Slack notification sent');
            } catch (error) {
              core.warning(`Failed to send Slack notification: ${error.message}`);
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  create-issue:
    if: github.event_name == 'workflow_dispatch'
    name: Create issue on demand
=======
      taskLabels:
        description: 'Comma-separated labels for the task'
        required: false

jobs:
  create_task_branch:
>>>>>>> origin/main
    runs-on: ubuntu-latest
    # Condition to run only for my-codex-bot assignee or workflow_dispatch
    if: (github.event_name == 'issues' && github.actor == 'LuminLynx') || github.event_name == 'workflow_dispatch'
    outputs:
      branch_name: ${{ steps.create_branch.outputs.branch_name }}
      task_file_path: ${{ steps.set_paths.outputs.task_file_path }}

    steps:
<<<<<<< HEAD
      - name: Validate inputs
        uses: actions/github-script@v7
        with:
          script: |
            const { core } = require('@actions/github-script');
            const title = '${{ inputs.title }}';
            const labels = '${{ inputs.labels }}';
            
            // Validate title
            if (!title || title.trim().length === 0) {
              core.setFailed('Title cannot be empty');
              return;
            }
            
            if (title.length > 256) {
              core.setFailed('Title must be 256 characters or less');
              return;
            }
            
            // Validate labels format
            if (labels) {
              const labelArray = labels.split(',').map(l => l.trim()).filter(l => l.length > 0);
              const invalidLabels = labelArray.filter(l => l.length > 50 || !/^[a-zA-Z0-9\s\-_]+$/.test(l));
              if (invalidLabels.length > 0) {
                core.setFailed(`Invalid label format: ${invalidLabels.join(', ')}`);
                return;
              }
            }
            
            core.info('âœ… Input validation passed');
      
      - id: create
=======
      - name: 'Checkout repository'
        uses: actions/checkout@v4

      - name: 'Set Environment Variables'
        id: set_env
        run: |
          if [ "${{ github.event_name }}" == "issues" ]; then
            echo "ISSUE_NUMBER=${{ github.event.issue.number }}" >> $GITHUB_ENV
            echo "TASK_TITLE=${{ github.event.issue.title }}" >> $GITHUB_ENV
            echo "TASK_BODY=${{ github.event.issue.body }}" >> $GITHUB_ENV
          else
            echo "ISSUE_NUMBER=${{ github.event.inputs.issueNumber }}" >> $GITHUB_ENV
            echo "TASK_TITLE=${{ github.event.inputs.taskTitle }}" >> $GITHUB_ENV
            echo "TASK_BODY=${{ github.event.inputs.taskBody }}" >> $GITHUB_ENV
          fi

      - name: 'Validate Inputs'
        run: |
          if [ -z "${{ env.ISSUE_NUMBER }}" ] || [ -z "${{ env.TASK_TITLE }}" ]; then
            echo "Error: Issue number and task title are required."
            exit 1
          fi

      - name: 'Generate Unique ID and Slug'
        id: generate_ids
        run: |
          UNIQUE_ID=$(date +%s)
          TASK_SLUG=$(echo "${{ env.TASK_TITLE }}" | iconv -t ascii//TRANSLIT | sed -r s/[~\^]+//g | sed -r s/[^a-zA-Z0-9]+/-/g | sed -r s/^-+\|-+$//g | tr A-Z a-z)
          echo "UNIQUE_ID=$UNIQUE_ID" >> $GITHUB_ENV
          echo "TASK_SLUG=$TASK_SLUG" >> $GITHUB_ENV
          echo "unique_id=$UNIQUE_ID" >> $GITHUB_OUTPUT
          echo "task_slug=$TASK_SLUG" >> $GITHUB_OUTPUT

      - name: 'Set Paths'
        id: set_paths
        run: |
          BRANCH_NAME="task/${{ env.ISSUE_NUMBER }}-${{ steps.generate_ids.outputs.task_slug }}-${{ steps.generate_ids.outputs.unique_id }}"
          TASK_FILE_PATH="tasks/${{ env.ISSUE_NUMBER }}/${{ steps.generate_ids.outputs.task_slug }}-${{ steps.generate_ids.outputs.unique_id }}.md"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "task_file_path=$TASK_FILE_PATH" >> $GITHUB_OUTPUT

      - name: 'Create new branch'
        id: create_branch
>>>>>>> origin/main
        uses: actions/github-script@v7
        with:
          script: |
            const branchName = '${{ steps.set_paths.outputs.branch_name }}';
            let retries = 3;
            while (retries > 0) {
              try {
                await github.rest.git.createRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `refs/heads/${branchName}`,
                  sha: context.sha
                });
                console.log(`Branch ${branchName} created successfully.`);
                core.setOutput('branch_name', branchName);
                return;
              } catch (error) {
                console.error(`Failed to create branch: ${error.message}. Retries left: ${retries - 1}`);
                retries--;
                await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds before retrying
              }
            }
            core.setFailed('Could not create branch after multiple retries.');
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

<<<<<<< HEAD
            // Retry mechanism
            const retryWithBackoff = async (fn, maxRetries = 3, baseDelay = 1000) => {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  return await fn();
                } catch (error) {
                  const isRetryable = error.status >= 500 || error.status === 429 || error.code === 'ECONNRESET';
                  if (attempt === maxRetries || !isRetryable) {
                    core.error(`Failed after ${attempt} attempts: ${error.message}`);
                    throw error;
                  }
                  const delay = baseDelay * Math.pow(2, attempt - 1);
                  core.warning(`Attempt ${attempt} failed: ${error.message}. Retrying in ${delay}ms...`);
                  await new Promise(resolve => setTimeout(resolve, delay));
                }
              }
            };

            const { owner, repo } = context.repo;
            
            const issue = await retryWithBackoff(async () => {
              return await github.rest.issues.create({
                owner,
                repo,
                title,
                body,
                labels,
              });
            });

            core.info(`âœ… Created issue #${issue.data.number}.`);
            core.summary
              .addHeading('âœ… Issue Created Successfully')
              .addRaw(`**Issue:** #${issue.data.number}`)
              .addRaw(`\n**Title:** ${title}`)
              .addRaw(`\n**URL:** ${issue.data.html_url}`)
              .write();
            return issue.data.number.toString();

      - name: Log issue number
        run: echo "Created issue #${{ steps.create.outputs.result }}"
      
      - name: Send notification for workflow_dispatch
        if: always() && inputs.notify_slack && secrets.SLACK_WEBHOOK_URL != ''
        uses: actions/github-script@v7
        with:
          script: |
            const { core } = require('@actions/github-script');
            const issueNumber = '${{ steps.create.outputs.result }}';
            const webhookUrl = process.env.SLACK_WEBHOOK_URL;
            
            if (!webhookUrl) {
              core.info('SLACK_WEBHOOK_URL not configured, skipping notification');
              return;
            }
            
            const payload = {
              attachments: [{
                color: 'good',
                title: 'âœ… Issue Created via Workflow Dispatch',
                fields: [
                  { title: 'Issue', value: `#${issueNumber}`, short: true },
                  { title: 'Repository', value: context.repo.owner + '/' + context.repo.repo, short: true },
                  { title: 'Title', value: '${{ inputs.title }}', short: false }
                ],
                footer: 'GitHub Actions',
                ts: Math.floor(Date.now() / 1000)
              }]
            };
            
            try {
              const https = require('https');
              const data = JSON.stringify(payload);
              const options = {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Content-Length': data.length
                }
              };
              
              await new Promise((resolve, reject) => {
                const req = https.request(webhookUrl, options, (res) => {
                  res.on('data', () => {});
                  res.on('end', () => resolve());
                });
                req.on('error', reject);
                req.write(data);
                req.end();
              });
              
              core.info('âœ… Slack notification sent');
            } catch (error) {
              core.warning(`Failed to send Slack notification: ${error.message}`);
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
=======
  create_task_file:
    needs: create_task_branch
    runs-on: ubuntu-latest
    if: success()

    steps:
      - name: 'Checkout repository'
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.create_task_branch.outputs.branch_name }}

      - name: 'Set Environment Variables from previous job'
        run: |
          if [ "${{ github.event_name }}" == "issues" ]; then
            echo "TASK_TITLE=${{ github.event.issue.title }}" >> $GITHUB_ENV
            echo "TASK_BODY=${{ github.event.issue.body }}" >> $GITHUB_ENV
          else
            echo "TASK_TITLE=${{ github.event.inputs.taskTitle }}" >> $GITHUB_ENV
            echo "TASK_BODY=${{ github.event.inputs.taskBody }}" >> $GITHUB_ENV
          fi

      - name: 'Create task file'
        run: |
          TASK_FILE_PATH="${{ needs.create_task_branch.outputs.task_file_path }}"
          mkdir -p $(dirname "$TASK_FILE_PATH")
          echo "---" > "$TASK_FILE_PATH"
          echo "title: ${{ env.TASK_TITLE }}" >> "$TASK_FILE_PATH"
          echo "issue: ${{ github.event.issue.number || github.event.inputs.issueNumber }}" >> "$TASK_FILE_PATH"
          echo "---" >> "$TASK_FILE_PATH"
          echo "" >> "$TASK_FILE_PATH"
          echo "${{ env.TASK_BODY }}" >> "$TASK_FILE_PATH"
          echo "Task file created at ${TASK_FILE_PATH}"

      - name: 'Commit and push task file'
        uses: actions/github-script@v7
        with:
          script: |
            const { exec } = require('child_process');
            exec('git config --global user.name "github-actions[bot]"', (err) => { if (err) core.setFailed(err.message); });
            exec('git config --global user.email "github-actions[bot]@users.noreply.github.com"', (err) => { if (err) core.setFailed(err.message); });
            exec('git add .', (err) => { if (err) core.setFailed(err.message); });
            exec('git commit -m "Create task file for issue #${{ github.event.issue.number || github.event.inputs.issueNumber }}"', (err) => { if (err) core.setFailed(err.message); });
            exec('git push origin ${{ needs.create_task_branch.outputs.branch_name }}', (err) => { if (err) core.setFailed(err.message); });

  create_pull_request:
    needs: create_task_file
    runs-on: ubuntu-latest
    if: success()

    steps:
      - name: 'Create Pull Request'
        uses: actions/github-script@v7
        with:
          script: |
            const branchName = '${{ needs.create_task_branch.outputs.branch_name }}';
            const issueNumber = '${{ github.event.issue.number || github.event.inputs.issueNumber }}';
            const prTitle = 'Task for Issue #' + issueNumber;
            const prBody = 'This PR addresses issue #' + issueNumber + '. Please review the changes.';
            let retries = 3;
            while (retries > 0) {
              try {
                const { data: pr } = await github.rest.pulls.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: prTitle,
                  head: branchName,
                  base: 'main',
                  body: prBody
                });
                console.log(`Pull request #${pr.number} created successfully.`);
                
                // Add labels if provided
                const labels = '${{ github.event.inputs.taskLabels }}';
                if (labels) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    labels: labels.split(',').map(label => label.trim())
                  });
                }
                return;
              } catch (error) {
                console.error(`Failed to create pull request: ${error.message}. Retries left: ${retries - 1}`);
                retries--;
                await new Promise(resolve => setTimeout(resolve, 2000));
              }
            }
            core.setFailed('Could not create pull request after multiple retries.');
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  notify_status:
    needs: [create_pull_request]
    runs-on: ubuntu-latest
    if: always() # Run whether jobs succeed or fail

    steps:
      - name: 'Send Notification'
        run: |
          if [ "${{ needs.create_pull_request.result }}" == "success" ]; then
            echo "Workflow completed successfully!"
            # Add your notification command here (e.g., Slack, Email)
          else
            echo "Workflow failed. Please check the logs."
            # Add your failure notification command here
          fi
>>>>>>> origin/main
