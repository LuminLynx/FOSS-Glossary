name: Issue Task PR Automation

on:
  issues:
    types:
      - assigned
  workflow_dispatch:
    inputs:
      title:
        description: Issue title for Codex to create
        required: true
        type: string
      body:
        description: Issue body
        required: false
        type: string
      labels:
        description: Comma-separated labels
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  handle-issue-assignment:
    if: github.event_name == 'issues'
    name: Handle assigned issues
    runs-on: ubuntu-latest
    steps:
      - name: Prepare task branch and PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const BOT_USERNAME = 'my-codex-bot';
            const { core, context, github } = require('@actions/github-script');

            const assignedUser = context.payload.assignee;
            if (!assignedUser || assignedUser.login !== BOT_USERNAME) {
              core.info('Issue not assigned to the Codex bot. Skipping.');
              return;
            }

            const { owner, repo } = context.repo;
            const issue = context.payload.issue;
            const repository = context.payload.repository;
            const defaultBranch = repository.default_branch;
            const issueNumber = issue.number;

            const slugFromTitle = (title) => {
              const base = title
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, '')
                .slice(0, 40);
              return base || `issue-${issueNumber}`;
            };

            const slug = slugFromTitle(issue.title);
            const branchName = `task/${issueNumber}-${slug}`;
            const filePath = `tasks/${issueNumber}-${slug}.md`;

            const ensureBranch = async () => {
              const refName = `heads/${branchName}`;
              try {
                await github.rest.git.getRef({ owner, repo, ref: refName });
                core.info(`Branch ${branchName} already exists.`);
              } catch (error) {
                if (error.status !== 404) throw error;
                const baseRef = await github.rest.git.getRef({ owner, repo, ref: `heads/${defaultBranch}` });
                await github.rest.git.createRef({
                  owner,
                  repo,
                  ref: `refs/${refName}`,
                  sha: baseRef.data.object.sha,
                });
                core.info(`Created branch ${branchName} from ${defaultBranch}.`);
              }
            };

            const upsertTaskFile = async () => {
              const safeTitle = issue.title.replace(/"/g, '\\"');
              const content = `---\nissue: #${issueNumber}\ntitle: "${safeTitle}"\nassignee: @${BOT_USERNAME}\nbranch: ${branchName}\n---\n\n## Checklist\n\n- [ ] Review issue requirements\n- [ ] Implement solution\n- [ ] Open pull request\n- [ ] Notify repository owner\n`;
              const encodedContent = Buffer.from(content, 'utf8').toString('base64');

              let currentSha;
              try {
                const existing = await github.rest.repos.getContent({
                  owner,
                  repo,
                  path: filePath,
                  ref: branchName,
                });
                if (!Array.isArray(existing.data)) {
                  currentSha = existing.data.sha;
                }
              } catch (error) {
                if (error.status !== 404) throw error;
              }

              await github.rest.repos.createOrUpdateFileContents({
                owner,
                repo,
                path: filePath,
                message: `chore: track task #${issueNumber}`,
                content: encodedContent,
                branch: branchName,
                sha: currentSha,
              });
              core.info(`Updated ${filePath} on ${branchName}.`);
            };

            const ensurePullRequest = async () => {
              const head = `${owner}:${branchName}`;
              const existing = await github.rest.pulls.list({
                owner,
                repo,
                head,
                base: defaultBranch,
                state: 'open',
              });

              if (existing.data.length > 0) {
                core.info(`Reusing existing PR ${existing.data[0].html_url}.`);
                return existing.data[0];
              }

              const title = `task: #${issueNumber} ${issue.title}`.substring(0, 250);
              const body = `Automated task preparation for #${issueNumber}.\n\n- Issue: #${issueNumber}\n- Assignee: @${BOT_USERNAME}\n- Branch: \`${branchName}\``;

              const pr = await github.rest.pulls.create({
                owner,
                repo,
                title,
                head: branchName,
                base: defaultBranch,
                body,
              });
              core.info(`Created PR ${pr.data.html_url}.`);
              return pr.data;
            };

            const ensureIssueComment = async (prUrl) => {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number: issueNumber,
              });

              const alreadyCommented = comments.some(
                (comment) => comment.user?.login === BOT_USERNAME && comment.body.includes(prUrl)
              );

              if (alreadyCommented) {
                core.info('Issue already has automation comment.');
                return;
              }

              const body = `Automation update: opened ${prUrl} from branch \`${branchName}\`. The task file lives at \`${filePath}\`.`;
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body,
              });
              core.info('Posted comment linking to PR.');
            };

            await ensureBranch();
            await upsertTaskFile();
            const pr = await ensurePullRequest();
            await ensureIssueComment(pr.html_url);

            core.info('Issue assignment processing complete.');

  create-issue:
    if: github.event_name == 'workflow_dispatch'
    name: Create issue on demand
    runs-on: ubuntu-latest
    outputs:
      issue-number: ${{ steps.create.outputs.result }}
    steps:
      - id: create
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const { core, context, github } = require('@actions/github-script');
            const title = core.getInput('title', { required: true });
            const body = core.getInput('body') || '';
            const labelsInput = core.getInput('labels') || '';
            const labels = labelsInput
              .split(',')
              .map((label) => label.trim())
              .filter((label) => label.length > 0);

            const { owner, repo } = context.repo;
            const issue = await github.rest.issues.create({
              owner,
              repo,
              title,
              body,
              labels,
            });

            core.info(`Created issue #${issue.data.number}.`);
            return issue.data.number.toString();

      - name: Log issue number
        run: echo "Created issue #${{ steps.create.outputs.result }}"
