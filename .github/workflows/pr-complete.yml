# .github/workflows/pr-complete.yml
# This REPLACES both validate-score.yml and pr-enhancer.yml with a single unified workflow
name: PR Review System

on:
  pull_request_target:
    paths:
      - 'terms.yaml'
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  # Job: Validate and Score (always runs)
  validate-and-score:
    runs-on: ubuntu-latest
    if: always()      # Run even if other conditional jobs (now removed) would have been skipped
    steps:
      - name: Checkout base repository
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.pull_request.base.sha }}
          fetch-depth: 0
          persist-credentials: false
      
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci --include=dev --no-audit --no-fund

      - name: Prepare PR terms.yaml snapshot
        id: pr-terms
        env:
          PR_REPO: ${{ github.event.pull_request.head.repo.full_name }}
          PR_REF: ${{ github.event.pull_request.head.sha }}
        run: |
          cp terms.yaml terms.base.yaml

          git fetch --no-tags --depth=1 https://github.com/$PR_REPO.git $PR_REF:refs/remotes/pr/head

          if git cat-file -e refs/remotes/pr/head:terms.yaml 2>/dev/null; then
            git show refs/remotes/pr/head:terms.yaml > terms.yaml
            echo "terms_present=true" >> "$GITHUB_OUTPUT"
          else
            echo "::warning::terms.yaml not found in PR head; using empty glossary for validation."
            printf "terms: []\n" > terms.yaml
            echo "terms_present=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Lint PR terms.yaml
        id: lint
        if: steps.pr-terms.outputs.terms_present == 'true'
        continue-on-error: true
        run: |
          python3 -m pip install --disable-pip-version-check --quiet yamllint
          yamllint -d "{extends: relaxed, rules: {document-start: disable, line-length: disable}}" -f parsable terms.yaml 2>&1 | tee lint-output.txt
          EXIT_CODE=${PIPESTATUS[0]}
          echo "exit_code=$EXIT_CODE" >> "$GITHUB_OUTPUT"
          {
            echo 'lint_output<<EOF'
            cat lint-output.txt
            echo EOF
          } >> "$GITHUB_OUTPUT"
          exit $EXIT_CODE

      - name: Detect glossary changes
        id: glossary
        env:
          BASE_TERMS_PATH: terms.base.yaml
          PR_TERMS_PATH: terms.yaml
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const yaml = require('js-yaml');

          const outputPath = process.env.GITHUB_OUTPUT;
          const basePath = process.env.BASE_TERMS_PATH || 'terms.base.yaml';
          const prPath = process.env.PR_TERMS_PATH || 'terms.yaml';

          const defaults = {
            terms_changed: 'false',
            has_new_slugs: 'false',
            new_slug_count: '0',
            primary_slug: '',
            new_slugs: '',
            parse_error: 'false',
            parse_error_message: '',
            parse_error_excerpt: ''
          };

          function writeOutput(key, value) {
            fs.appendFileSync(outputPath, `\n${key}=${value}`);
          }

          for (const [key, value] of Object.entries(defaults)) {
            writeOutput(key, value);
          }

          function readTrimmed(path) {
            try {
              return fs.readFileSync(path, 'utf8').trim();
            } catch (error) {
              return '';
            }
          }

          const baseContent = readTrimmed(basePath);
          const prContent = readTrimmed(prPath);

          if (baseContent === prContent) {
            return;
          }

          if (!baseContent && !prContent) {
            return;
          }

          writeOutput('terms_changed', 'true');

          let baseTerms = [];
          let prTerms = [];

          if (baseContent) {
            try {
              const parsedBase = yaml.load(baseContent);
              if (parsedBase && Array.isArray(parsedBase.terms)) {
                baseTerms = parsedBase.terms;
              }
            } catch (error) {
              console.warn('Unable to parse base terms.yaml:', error.message);
            }
          }

          if (prContent) {
            try {
              const parsedPr = yaml.load(prContent);
              if (parsedPr && Array.isArray(parsedPr.terms)) {
                prTerms = parsedPr.terms;
              }
            } catch (error) {
              const parseMessage = error && error.message ? error.message : String(error);
              const excerpt = prContent.slice(0, 2000);

              console.error('Unable to parse PR terms.yaml:', error);
              console.error('PR terms.yaml contents (first 2000 chars):\n' + excerpt);

              writeOutput('parse_error', 'true');
              writeOutput('parse_error_message', parseMessage.replace(/[\r\n]+/g, ' '));
              fs.appendFileSync(outputPath, `\nparse_error_excerpt<<EOF\n${excerpt}\nEOF`);

              return;
            }
          }

          const baseSlugs = new Set((baseTerms || []).map(term => term && term.slug).filter(Boolean));
          const newSlugs = (prTerms || [])
            .map(term => term && term.slug)
            .filter(slug => slug && !baseSlugs.has(slug));

          if (newSlugs.length > 0) {
            writeOutput('has_new_slugs', 'true');
            writeOutput('new_slug_count', String(newSlugs.length));
            writeOutput('primary_slug', newSlugs[newSlugs.length - 1]);
            writeOutput('new_slugs', newSlugs.join(','));
          }
          NODE
      
      # Step 1: Validate the YAML
      - name: Validate terms
        id: validate
        if: steps.glossary.outputs.terms_changed == 'true' && steps.glossary.outputs.parse_error != 'true' && (steps.lint.outputs.exit_code == '' || steps.lint.outputs.exit_code == '0')
        #continue-on-error: true
        run: |
          node scripts/validateTerms.js 2>&1 | tee validation-output.txt
          VALIDATION_EXIT_CODE=${PIPESTATUS[0]}
          echo "valid=$VALIDATION_EXIT_CODE" >> $GITHUB_OUTPUT
          {
            echo 'validation_output<<EOF'
            cat validation-output.txt
            echo EOF
          } >> $GITHUB_OUTPUT
          exit $VALIDATION_EXIT_CODE

      # Step 2: Score if valid
      - name: Score terms
        id: score
        if: steps.validate.outputs.valid == '0' && steps.glossary.outputs.has_new_slugs == 'true'
        run: |
          TARGET_SLUG=${{ steps.glossary.outputs.primary_slug }} node scripts/quickScore.js > score-output.txt
          cat score-output.txt
          echo "score=$(grep 'SCORE:' score-output.txt | cut -d: -f2)" >> $GITHUB_OUTPUT
          echo "badge=$(grep 'BADGE:' score-output.txt | cut -d: -f2-)" >> $GITHUB_OUTPUT

      # Step 3: Get PR statistics
      - name: Get glossary stats
        id: stats
        if: steps.validate.outputs.valid == '0'
        run: |
          node -e "
          const fs = require('fs');
          const yaml = require('js-yaml');
          
          try {
            const data = yaml.load(fs.readFileSync('terms.yaml', 'utf8'));
            const terms = data.terms || [];
            
            // Count and analyze
            console.log('total_terms=' + terms.length);
            
            // Find high score
            let highScore = 0;
            let topScorer = '';
            terms.forEach(term => {
              let score = 0;
              if (term.term && term.definition) score += 20;
              if (term.humor) score += Math.min(30, Math.floor(term.humor.length / 10) * 5);
              if (term.explanation) score += 20;
              if (term.see_also && term.see_also.length > 0) score += Math.min(20, term.see_also.length * 10);
              if (term.tags && term.tags.length > 0) score += 10;
              if (score > highScore) {
                highScore = score;
                topScorer = term.term;
              }
            });
            
            console.log('high_score=' + highScore);
            console.log('top_scorer=' + topScorer);
            
            console.log('new_term=Unknown');
          } catch (error) {
            console.log('total_terms=0');
            console.log('high_score=0');
            console.log('top_scorer=None');
            console.log('new_term=Unknown');
          }
          " >> $GITHUB_OUTPUT
      
      # Step 4: Comment with results (combines all information)
      # Note: Skip commenting on forked PRs to avoid "Resource not accessible by integration"
      - name: Comment PR results
        uses: actions/github-script@v6
        if: always()
      # && github.event.pull_request.head.repo.fork == false
        with:
          github-token: ${{ github.token }}
          script: |
            // Get all our data
            const termsChanged = '${{ steps.glossary.outputs.terms_changed }}' === 'true';
            const hasNewSlugs = '${{ steps.glossary.outputs.has_new_slugs }}' === 'true';
            const newSlugList = '${{ steps.glossary.outputs.new_slugs }}';
            const primarySlug = '${{ steps.glossary.outputs.primary_slug }}';
            const newSlugCountRaw = '${{ steps.glossary.outputs.new_slug_count }}';
            const isValid = '${{ steps.validate.outputs.valid }}' === '0';
            const parseError = '${{ steps.glossary.outputs.parse_error }}' === 'true';
            const parseErrorMessage = '${{ steps.glossary.outputs.parse_error_message }}';
            const parseErrorExcerpt = `${{ steps.glossary.outputs.parse_error_excerpt }}`;
            const lintExitCodeRaw = '${{ steps.lint.outputs.exit_code }}';
            const lintOutput = `${{ steps.lint.outputs.lint_output }}`;
            const lintFailed = Boolean(lintExitCodeRaw && lintExitCodeRaw !== '0');
            const validationOutputRaw = `${{ steps.validate.outputs.validation_output }}`;
            const validationOutput = validationOutputRaw ? validationOutputRaw : '';
            const score = '${{ steps.score.outputs.score }}' || '0';
            const badge = '${{ steps.score.outputs.badge }}' || '';
            const totalTerms = '${{ steps.stats.outputs.total_terms }}' || '0';
            const highScore = '${{ steps.stats.outputs.high_score }}' || '0';
            const topScorer = '${{ steps.stats.outputs.top_scorer }}' || 'None';
            const newTerm = primarySlug || 'Unknown';
            const newSlugCount = parseInt(newSlugCountRaw || '0', 10) || 0;

            let comment = '';

            if (parseError) {
              comment = `## ❌ terms.yaml could not be parsed\n\n`;
              comment += `YAML parsing failed with this message:\n\n`;
              comment += '```\n' + (parseErrorMessage || 'Unknown parser error') + '\n```\n\n';

              if (lintFailed && lintOutput.trim()) {
                comment += `### 🔍 yamllint details\n`;
                comment += '```\n' + lintOutput.trim() + '\n```\n\n';
              }

              if (parseErrorExcerpt && parseErrorExcerpt.trim()) {
                comment += `### 📄 File snippet (first 2000 characters)\n`;
                comment += '```yaml\n' + parseErrorExcerpt.trim() + '\n```\n\n';
              }

              comment += `Please fix the YAML syntax issues above and push an update. I'll retry automatically. 🤖`;
            } else if (lintFailed) {
              comment = `## ❌ YAML linting failed\n\n`;
              comment += `yamllint reported the following issues:\n`;
              comment += '```\n' + lintOutput.trim() + '\n```\n\n';
              comment += `Please address these lint errors and push an update. I'll re-check automatically. 🤖`;
            } else if (!termsChanged) {
              comment = `## ℹ️ No glossary changes detected\n\n`;
              comment += `terms.yaml is unchanged in the latest commit. Validation and scoring were skipped.\n\n`;
              comment += `I'll keep watching for glossary updates on future pushes. 🤖`;
            } else if (!isValid) {
              // VALIDATION FAILED
              comment = `## ❌ Validation Failed!\n\n`;
              comment += `### The Issue:\n`;
              const cleanedOutput = validationOutput ? validationOutput.replace(/✅.*\n/g, '').trim() : '';
              comment += '```\n' + (cleanedOutput || 'Validation failed, but no output was captured.') + '\n```\n\n';

              comment += `### 🔧 How to Fix:\n`;
              comment += `1. Check your YAML indentation (use 2 spaces, not tabs)\n`;
              comment += `2. Make sure you have both \`term\` and \`definition\` fields\n`;
              comment += `3. Put quotes around values with special characters\n`;
              comment += `4. Check for typos in field names\n\n`;
              
              comment += `### 📝 Valid Example:\n`;
              comment += '```yaml\n';
              comment += '- term: "Example"\n';
              comment += '  definition: "A sample definition"\n';
              comment += '  humor: "Something funny"\n';
              comment += '  tags: ["example", "test"]\n';
              comment += '```\n\n';
              
              comment += `*Fix these issues and push again. I'll re-check automatically!* 🤖`;
              
            } else {
              // VALIDATION PASSED - Show score
              comment = `## ✅ Validation Passed!\n\n`;

              if (hasNewSlugs && newSlugCount > 0) {
                if (newSlugCount === 1) {
                  comment += `### 📝 New Term: "${newTerm}"\n\n`;
                } else {
                  const slugDisplay = newSlugList.split(',').filter(Boolean).map(slug => `"${slug}"`).join(', ');
                  comment += `### 📝 New Terms (${newSlugCount}): ${slugDisplay}\n\n`;
                }

                comment += `### 📊 Your Score: ${score}/100\n\n`;

                // Score tier message
                if (score >= 90) {
                  comment += `# 🏆 LEGENDARY CONTRIBUTION!\n`;
                  comment += `You've achieved excellence! This is Hall of Fame material! 🌟\n\n`;
                } else if (score >= 80) {
                  comment += `## 🔥 AMAZING!\n`;
                  comment += `Outstanding work! You're in the top tier! 💪\n\n`;
                } else if (score >= 70) {
                  comment += `### 💪 Great Job!\n`;
                  comment += `Solid contribution! Well above average! 👏\n\n`;
                } else if (score >= 60) {
                  comment += `### 👍 Good Work!\n`;
                  comment += `Nice contribution! Consider adding more details for bonus points!\n\n`;
                } else {
                  comment += `### 🌱 Good Start!\n`;
                  comment += `Thanks for contributing! Here's how to boost your score:\n\n`;
                }

                // Achievements
                if (badge) {
                  comment += `### 🏅 Achievements Unlocked:\n`;
                  badge.split(',').forEach(b => {
                    const trimmed = b.trim();
                    if (trimmed) comment += `- ${trimmed}\n`;
                  });
                  comment += '\n';
                }

                // Improvement tips for lower scores
                if (score < 80) {
                  comment += `### 💡 Quick Tips to Improve:\n`;
                  if (!badge.includes('Comedy Gold')) {
                    comment += `- Add more humor (current max: 30 points)\n`;
                  }
                  comment += `- Add an \`explanation\` field (+20 points)\n`;
                  comment += `- Include \`see_also\` references (+20 points)\n`;
                  comment += `- Add relevant \`tags\` (+10 points)\n\n`;
                }

                // Leaderboard section
                comment += `### 🏆 Current Leaderboard\n`;
                comment += `- **Your Score:** ${score}/100\n`;
                comment += `- **High Score:** ${highScore}/100 (${topScorer})\n`;
                comment += `- **Total Terms:** ${totalTerms}\n\n`;

                // Comparison
                if (parseInt(score) >= parseInt(highScore)) {
                  comment += `**🎊 NEW HIGH SCORE! You're the champion!** 🎊\n\n`;
                } else {
                  const diff = parseInt(highScore) - parseInt(score);
                  comment += `You're ${diff} points away from the high score! ${diff <= 10 ? 'So close! 🔥' : 'Keep pushing! 💪'}\n\n`;
                }
              } else {
                comment += `### 📋 Summary\n`;
                comment += `- No brand-new slugs detected in this update.\n`;
                comment += `- Validation succeeded for the existing glossary entries.\n\n`;
                comment += `Scoring only runs for newly added slugs per the PR gating rules. ✅\n\n`;
                comment += `Total terms in the glossary: ${totalTerms}.\n\n`;
              }

              comment += `---\n`;
              comment += `*Ready for merge after maintainer review!* ✨`;
            }
            
            // Check if we already commented
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            // Look for our validation comment (not the welcome message)
            const validationComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              (
                comment.body.includes('✅ Validation Passed') ||
                comment.body.includes('❌ Validation Failed') ||
                comment.body.includes('❌ YAML linting failed') ||
                comment.body.includes('❌ terms.yaml could not be parsed') ||
                comment.body.includes('ℹ️ No glossary changes detected')
              )
            );
            
            if (validationComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: validationComment.id,
                body: comment
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            }

      - name: Fail workflow on lint or parse errors
        if: steps.glossary.outputs.parse_error == 'true' || (steps.lint.outputs.exit_code != '' && steps.lint.outputs.exit_code != '0')
        run: |
          echo "Lint or parse errors detected in terms.yaml."
          exit 1
