# .github/workflows/pr-complete.yml
# This REPLACES both validate-score.yml and pr-enhancer.yml with a single unified workflow
name: PR Review System

on:
  pull_request_target:
    paths:
      - 'terms.yaml'
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  # Job: Validate and Score (always runs)
  validate-and-score:
    runs-on: ubuntu-latest
    if: always()      # Run even if other conditional jobs (now removed) would have been skipped
    steps:
      - name: Checkout PR head
        uses: actions/checkout@v3
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0  # Need full history for diff
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci --include=dev --no-audit --no-fund

      - name: Add base repo as remote and fetch base branch
        run: |
          git remote add base https://github.com/${{ github.event.pull_request.base.repo.full_name }} || true
          git fetch base ${{ github.event.pull_request.base.ref }} --depth=1

      - name: Detect glossary changes
        id: glossary
        run: |
          BASE_REF="${{ github.event.pull_request.base.ref }}"
          {
            echo 'terms_changed=false'
            echo 'has_new_slugs=false'
            echo 'new_slug_count=0'
            echo 'primary_slug='
            echo 'new_slugs='
          } >> "$GITHUB_OUTPUT"

          node - <<'NODE'
          const fs = require('fs');
          const yaml = require('js-yaml');
          const { execSync } = require('child_process');

          const baseRef = process.env.BASE_REF;
          const outputPath = process.env.GITHUB_OUTPUT;

          function writeOutput(key, value) {
            fs.appendFileSync(outputPath, `\n${key}=${value}`);
          }

          let headContent = '';
          try {
            headContent = fs.readFileSync('terms.yaml', 'utf8');
          } catch (error) {
            console.warn('terms.yaml not present in PR head; treating as empty.');
            headContent = '';
          }

          let baseContent = '';
          try {
            baseContent = execSync(`git show base/${baseRef}:terms.yaml`, { encoding: 'utf8' });
          } catch (error) {
            // If the file does not exist on the base branch (e.g., first contribution), treat as empty.
            baseContent = '';
          }

          const termsChanged = headContent.trim() !== baseContent.trim();
          writeOutput('terms_changed', termsChanged);

          if (!termsChanged) {
            return;
          }

          let baseTerms = [];
          let headTerms = [];

          try {
            if (baseContent.trim()) {
              const parsedBase = yaml.load(baseContent);
              if (parsedBase && Array.isArray(parsedBase.terms)) {
                baseTerms = parsedBase.terms;
              }
            }
          } catch (error) {
            console.warn('Unable to parse base terms.yaml:', error.message);
          }

          try {
            const parsedHead = yaml.load(headContent);
            if (parsedHead && Array.isArray(parsedHead.terms)) {
              headTerms = parsedHead.terms;
            }
          } catch (error) {
            console.error('Unable to parse head terms.yaml:', error.message);
            process.exit(1);
          }

          const baseSlugs = new Set((baseTerms || []).map(term => term && term.slug).filter(Boolean));
          const newSlugs = (headTerms || [])
            .map(term => term && term.slug)
            .filter(slug => slug && !baseSlugs.has(slug));

          writeOutput('has_new_slugs', newSlugs.length > 0);
          writeOutput('new_slug_count', newSlugs.length);
          writeOutput('primary_slug', newSlugs.length > 0 ? newSlugs[newSlugs.length - 1] : '');
          writeOutput('new_slugs', newSlugs.join(','));
          NODE
      
      # Step 1: Validate the YAML
      - name: Validate terms
        id: validate
        if: steps.glossary.outputs.terms_changed == 'true'
        #continue-on-error: true
        run: |
          node scripts/validateTerms.js 2>&1 | tee validation-output.txt
          VALIDATION_EXIT_CODE=${PIPESTATUS[0]}
          echo "valid=$VALIDATION_EXIT_CODE" >> $GITHUB_OUTPUT
          {
            echo 'validation_output<<EOF'
            cat validation-output.txt
            echo EOF
          } >> $GITHUB_OUTPUT
          exit $VALIDATION_EXIT_CODE

      # Step 2: Score if valid
      - name: Score terms
        id: score
        if: steps.validate.outputs.valid == '0' && steps.glossary.outputs.has_new_slugs == 'true'
        run: |
          TARGET_SLUG=${{ steps.glossary.outputs.primary_slug }} node scripts/quickScore.js > score-output.txt
          cat score-output.txt
          echo "score=$(grep 'SCORE:' score-output.txt | cut -d: -f2)" >> $GITHUB_OUTPUT
          echo "badge=$(grep 'BADGE:' score-output.txt | cut -d: -f2-)" >> $GITHUB_OUTPUT

      # Step 3: Get PR statistics
      - name: Get glossary stats
        id: stats
        if: steps.validate.outputs.valid == '0'
        run: |
          node -e "
          const fs = require('fs');
          const yaml = require('js-yaml');
          
          try {
            const data = yaml.load(fs.readFileSync('terms.yaml', 'utf8'));
            const terms = data.terms || [];
            
            // Count and analyze
            console.log('total_terms=' + terms.length);
            
            // Find high score
            let highScore = 0;
            let topScorer = '';
            terms.forEach(term => {
              let score = 0;
              if (term.term && term.definition) score += 20;
              if (term.humor) score += Math.min(30, Math.floor(term.humor.length / 10) * 5);
              if (term.explanation) score += 20;
              if (term.see_also && term.see_also.length > 0) score += Math.min(20, term.see_also.length * 10);
              if (term.tags && term.tags.length > 0) score += 10;
              if (score > highScore) {
                highScore = score;
                topScorer = term.term;
              }
            });
            
            console.log('high_score=' + highScore);
            console.log('top_scorer=' + topScorer);
            
            console.log('new_term=Unknown');
          } catch (error) {
            console.log('total_terms=0');
            console.log('high_score=0');
            console.log('top_scorer=None');
            console.log('new_term=Unknown');
          }
          " >> $GITHUB_OUTPUT
      
      # Step 4: Comment with results (combines all information)
      # Note: Skip commenting on forked PRs to avoid "Resource not accessible by integration"
      - name: Comment PR results
        uses: actions/github-script@v6
        if: always()
      # && github.event.pull_request.head.repo.fork == false
        with:
          github-token: ${{ github.token }}
          script: |
            // Get all our data
            const termsChanged = '${{ steps.glossary.outputs.terms_changed }}' === 'true';
            const hasNewSlugs = '${{ steps.glossary.outputs.has_new_slugs }}' === 'true';
            const newSlugList = '${{ steps.glossary.outputs.new_slugs }}';
            const primarySlug = '${{ steps.glossary.outputs.primary_slug }}';
            const newSlugCountRaw = '${{ steps.glossary.outputs.new_slug_count }}';
            const isValid = '${{ steps.validate.outputs.valid }}' === '0';
            const validationOutput = `${{ steps.validate.outputs.validation_output }}`;
            const score = '${{ steps.score.outputs.score }}' || '0';
            const badge = '${{ steps.score.outputs.badge }}' || '';
            const totalTerms = '${{ steps.stats.outputs.total_terms }}' || '0';
            const highScore = '${{ steps.stats.outputs.high_score }}' || '0';
            const topScorer = '${{ steps.stats.outputs.top_scorer }}' || 'None';
            const newTerm = primarySlug || 'Unknown';
            const newSlugCount = parseInt(newSlugCountRaw || '0', 10) || 0;

            let comment = '';

            // Title based on whether it's first comment or update
            const isFirstRun = context.payload.action === 'opened';

            if (!termsChanged) {
              comment = `## ‚ÑπÔ∏è No glossary changes detected\n\n`;
              comment += `terms.yaml is unchanged in the latest commit. Validation and scoring were skipped.\n\n`;
              comment += `I'll keep watching for glossary updates on future pushes. ü§ñ`;
            } else if (!isValid) {
              // VALIDATION FAILED
              comment = `## ‚ùå Validation Failed!\n\n`;
              comment += `### The Issue:\n`;
              comment += '```\n' + validationOutput.replace(/‚úÖ.*\n/g, '').trim() + '\n```\n\n';

              comment += `### üîß How to Fix:\n`;
              comment += `1. Check your YAML indentation (use 2 spaces, not tabs)\n`;
              comment += `2. Make sure you have both \`term\` and \`definition\` fields\n`;
              comment += `3. Put quotes around values with special characters\n`;
              comment += `4. Check for typos in field names\n\n`;
              
              comment += `### üìù Valid Example:\n`;
              comment += '```yaml\n';
              comment += '- term: "Example"\n';
              comment += '  definition: "A sample definition"\n';
              comment += '  humor: "Something funny"\n';
              comment += '  tags: ["example", "test"]\n';
              comment += '```\n\n';
              
              comment += `*Fix these issues and push again. I'll re-check automatically!* ü§ñ`;
              
            } else {
              // VALIDATION PASSED - Show score
              comment = `## ‚úÖ Validation Passed!\n\n`;

              if (hasNewSlugs && newSlugCount > 0) {
                if (newSlugCount === 1) {
                  comment += `### üìù New Term: "${newTerm}"\n\n`;
                } else {
                  const slugDisplay = newSlugList.split(',').filter(Boolean).map(slug => `"${slug}"`).join(', ');
                  comment += `### üìù New Terms (${newSlugCount}): ${slugDisplay}\n\n`;
                }

                comment += `### üìä Your Score: ${score}/100\n\n`;

                // Score tier message
                if (score >= 90) {
                  comment += `# üèÜ LEGENDARY CONTRIBUTION!\n`;
                  comment += `You've achieved excellence! This is Hall of Fame material! üåü\n\n`;
                } else if (score >= 80) {
                  comment += `## üî• AMAZING!\n`;
                  comment += `Outstanding work! You're in the top tier! üí™\n\n`;
                } else if (score >= 70) {
                  comment += `### üí™ Great Job!\n`;
                  comment += `Solid contribution! Well above average! üëè\n\n`;
                } else if (score >= 60) {
                  comment += `### üëç Good Work!\n`;
                  comment += `Nice contribution! Consider adding more details for bonus points!\n\n`;
                } else {
                  comment += `### üå± Good Start!\n`;
                  comment += `Thanks for contributing! Here's how to boost your score:\n\n`;
                }

                // Achievements
                if (badge) {
                  comment += `### üèÖ Achievements Unlocked:\n`;
                  badge.split(',').forEach(b => {
                    const trimmed = b.trim();
                    if (trimmed) comment += `- ${trimmed}\n`;
                  });
                  comment += '\n';
                }

                // Improvement tips for lower scores
                if (score < 80) {
                  comment += `### üí° Quick Tips to Improve:\n`;
                  if (!badge.includes('Comedy Gold')) {
                    comment += `- Add more humor (current max: 30 points)\n`;
                  }
                  comment += `- Add an \`explanation\` field (+20 points)\n`;
                  comment += `- Include \`see_also\` references (+20 points)\n`;
                  comment += `- Add relevant \`tags\` (+10 points)\n\n`;
                }

                // Leaderboard section
                comment += `### üèÜ Current Leaderboard\n`;
                comment += `- **Your Score:** ${score}/100\n`;
                comment += `- **High Score:** ${highScore}/100 (${topScorer})\n`;
                comment += `- **Total Terms:** ${totalTerms}\n\n`;

                // Comparison
                if (parseInt(score) >= parseInt(highScore)) {
                  comment += `**üéä NEW HIGH SCORE! You're the champion!** üéä\n\n`;
                } else {
                  const diff = parseInt(highScore) - parseInt(score);
                  comment += `You're ${diff} points away from the high score! ${diff <= 10 ? 'So close! üî•' : 'Keep pushing! üí™'}\n\n`;
                }
              } else {
                comment += `### üìã Summary\n`;
                comment += `- No brand-new slugs detected in this update.\n`;
                comment += `- Validation succeeded for the existing glossary entries.\n\n`;
                comment += `Scoring only runs for newly added slugs per the PR gating rules. ‚úÖ\n\n`;
                comment += `Total terms in the glossary: ${totalTerms}.\n\n`;
              }

              comment += `---\n`;
              comment += `*Ready for merge after maintainer review!* ‚ú®`;
            }
            
            // Check if we already commented
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            // Look for our validation comment (not the welcome message)
            const validationComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              (comment.body.includes('‚úÖ Validation Passed') || comment.body.includes('‚ùå Validation Failed'))
            );
            
            if (validationComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: validationComment.id,
                body: comment
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            }
