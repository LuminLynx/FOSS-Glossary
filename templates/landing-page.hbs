{{!-- 
  FOSS Glossary Landing Page Template (Enhanced)
  
  This Handlebars template generates the landing page HTML with:
  - Dynamic search & filtering (client-side vanilla JS, ~5KB)
  - Beautiful animations and micro-interactions
  - Responsive design for mobile/tablet/desktop
  - Featured term spotlight
  - Visual score indicators and category badges
  - 12-16 recent terms visible on first load
  
  Template syntax:
  - {{variable}} - Auto-escaped HTML output (safe for user content)
  - {{{variable}}} - Unescaped output (use only for trusted content like CSS)
  - {{#if condition}} ... {{/if}} - Conditional rendering
  - {{#each array}} ... {{/each}} - Loop over arrays
  
  Data structure expected:
  - title: Page title string
  - canonicalUrl: Canonical URL for SEO
  - metaTags: Object with primary, og, and twitter arrays
  - styles: CSS styles string (unescaped)
  - statCards: Array of {number, label} objects
  - recentTermsList: Comma-separated string of recent terms
  - termCards: Array of term objects (16+ terms for search/filter)
  - featuredTerm: Single term object to highlight
  - scoringItems: Array of {emoji, text, points} objects
  - ctaButtons: Array of {text, href, className} objects
  - lastUpdated: Formatted date string
  - stats: Statistics object
  - artifactVersion: Git commit SHA
--}}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{{title}}</title>

    <!-- Primary Meta Tags -->
    {{#each metaTags.primary}}
      <meta name="{{name}}" content="{{content}}" />
    {{/each}}
    <link rel="canonical" href="{{canonicalUrl}}" />

    <!-- Open Graph / Facebook -->
    {{#each metaTags.og}}
      <meta property="{{property}}" content="{{content}}" />
    {{/each}}

    <!-- Twitter -->
    {{#each metaTags.twitter}}
      <meta name="{{name}}" content="{{content}}" />
    {{/each}}

    <!-- Favicon (optional - add later) -->
    <!-- <link rel="icon" type="image/png" href="assets/favicon.png"> -->

    <style>{{{styles}}}</style>
  </head>
  <body>
    <div class="container">
      <!-- HERO SECTION -->
      <div class="card hero-card">
        <div class="logo-section">
          <div class="logo" data-animate="bounce">
            <img src="./pwa/assets/logo.png" alt="FOSS Glossary Logo" />
          </div>
        </div>

        <h1 class="hero-title">ğŸš€ FOSS Glossary</h1>
        <p class="tagline">A gamified glossary of Free and Open Source Software
          terms, with humor, sarcasm, and honest truths.</p>

        <!-- RELEASE ANNOUNCEMENT -->
        {{#if release}}
          <div class="release-banner" data-animate="slideInDown">
            <p class="release-badge">ğŸ‰ Latest Release</p>
            <h2>v{{release.version}}</h2>
            <p>{{release.description}}</p>
            <a href="{{release.releaseUrl}}">View Release Notes â†’</a>
          </div>
        {{/if}}
      </div>

      <!-- LIVE STATISTICS -->
      <div class="card stats-card">
        <h2>ğŸ“Š Live Statistics</h2>
        <div class="live-stats">
          {{#each statCards}}
            <div
              class="stat-card"
              data-animate="fadeInUp"
              data-delay="{{@index}}"
            >
              <span class="stat-number">{{number}}</span>
              <span class="stat-label">{{label}}</span>
            </div>
          {{/each}}
        </div>
      </div>

      <!-- FEATURED TERM SPOTLIGHT -->
      {{#if featuredTerm}}
        <div class="card featured-section" data-animate="scaleIn">
          <h2>â­ Featured Term</h2>
          <div class="featured-term-card">
            <div class="featured-header">
              <h3>{{featuredTerm.term}}</h3>
              <div class="score-badge" data-score="{{featuredTerm.score}}">
                <span class="score-value">{{featuredTerm.score}}</span>
                <span class="score-label">/ 100</span>
              </div>
            </div>
            <p class="featured-definition">{{featuredTerm.definition}}</p>
            {{#if featuredTerm.humor}}
              <div class="featured-humor">
                <p>ğŸ˜‚ "{{featuredTerm.humor}}"</p>
              </div>
            {{/if}}
            {{#if featuredTerm.tags.length}}
              <div class="featured-tags">
                {{#each featuredTerm.tags}}
                  <span class="tag featured-tag">{{this}}</span>
                {{/each}}
              </div>
            {{/if}}
          </div>
        </div>
      {{/if}}

      <!-- RECENT ADDITIONS -->
      <div class="card recent-additions">
        <h2>ğŸ†• Latest Additions</h2>
        <p>Just added: <strong>{{recentTermsList}}</strong></p>
      </div>

      <!-- SEARCH & FILTER SECTION -->
      <div class="card search-section" data-animate="fadeIn">
        <h2>ğŸ” Explore Glossary</h2>
        <div class="search-container">
          <div class="search-input-wrapper">
            <input
              type="text"
              id="searchInput"
              class="search-input"
              placeholder="Search terms, definitions, or tags..."
              aria-label="Search glossary"
            />
            <span class="search-icon">ğŸ”</span>
          </div>

          <div class="filter-controls">
            <div class="filter-group">
              <label class="filter-label">
                <input
                  type="checkbox"
                  class="score-filter"
                  value="90-100"
                  data-label="Score 90+"
                />
                <span>ğŸ’¯ Perfectionist (90+)</span>
              </label>
              <label class="filter-label">
                <input
                  type="checkbox"
                  class="score-filter"
                  value="80-89"
                  data-label="Score 80-89"
                />
                <span>â­ Excellent (80+)</span>
              </label>
              <label class="filter-label">
                <input
                  type="checkbox"
                  class="score-filter"
                  value="0-79"
                  data-label="Score <80"
                />
                <span>ğŸ“– Learning (All)</span>
              </label>
            </div>

            <div class="filter-group">
              <label class="sort-label">
                Sort by:
                <select
                  id="sortSelect"
                  class="sort-select"
                  aria-label="Sort terms"
                >
                  <option value="date-desc">Most Recent</option>
                  <option value="score-desc">Highest Score</option>
                  <option value="score-asc">Lowest Score</option>
                  <option value="alpha-asc">Alphabetical (A-Z)</option>
                </select>
              </label>
            </div>
          </div>

          <div class="filter-tags-container" id="activeFilters"></div>
        </div>
        <p class="result-count" id="resultCount">Showing
          {{termCards.length}}
          of
          {{stats.totalTerms}}
          terms</p>
      </div>

      <!-- TERM GRID -->
      <div class="card terms-section">
        <h2>ğŸ†• Latest Terms</h2>
        <div class="term-grid" id="termGrid">
          {{#each termCards}}
            <div
              class="term-card"
              data-term="{{this.term}}"
              data-slug="{{this.slug}}"
              data-score="{{this.score}}"
              data-tags="{{this.tagsString}}"
              data-definition="{{this.definition}}"
              data-humor="{{this.humor}}"
              data-date="{{this.sortDate}}"
              data-animate="fadeInUp"
              data-delay="{{@index}}"
            >

              <div class="term-header">
                <h3>{{this.term}}</h3>
                <div class="score-bar-container">
                  <div
                    class="score-bar"
                    style="width: {{this.score}}%; background-color: {{this.scoreColor}};"
                  ></div>
                </div>
                <span
                  class="term-score"
                  style="color: {{this.scoreColor}}"
                >{{this.score}}</span>
              </div>

              <p class="term-definition">{{this.definition}}</p>

              {{#if this.humor}}
                <p class="term-humor">ğŸ˜‚ "{{this.humor}}"</p>
              {{/if}}

              {{#if this.tags.length}}
                <div class="term-tags">
                  {{#each this.tags}}
                    <span class="tag" data-tag="{{this}}">{{this}}</span>
                  {{/each}}
                </div>
              {{/if}}
            </div>
          {{/each}}
        </div>

        <div class="empty-state" id="emptyState" style="display: none;">
          <p>ğŸ˜• No terms match your filters. Try adjusting your search or
            clearing filters.</p>
        </div>
      </div>

      <!-- SCORING SYSTEM -->
      <div class="card scoring-section">
        <h2>ğŸ“Š How Scoring Works</h2>
        <div class="scoring-grid">
          {{#each scoringItems}}
            <div class="scoring-item" data-animate="fadeInUp">
              <div class="scoring-emoji">{{emoji}}</div>
              <h4>{{text}}</h4>
              <p>{{points}}</p>
            </div>
          {{/each}}
        </div>
        <div class="scoring-note">
          <p>ğŸ’¯ Score 90+ to become a legend!</p>
        </div>
      </div>

      <!-- CALL TO ACTION -->
      <div class="card cta-section">
        <h2>Ready to Contribute?</h2>
        <div class="cta">
          {{#each ctaButtons}}
            <a href="{{href}}" class="{{className}}" data-animate="slideInUp">
              {{text}}
            </a>
          {{/each}}
        </div>
      </div>

      <!-- FOOTER -->
      <div class="footer">
        <p class="last-updated">
          Last updated:
          {{lastUpdated}}
          |
          {{stats.totalTerms}}
          terms and growing!<br />
          Made with ğŸ’™ by the FOSS community
        </p>
      </div>
    </div>

    <script>
      window.__TERMS_JSON_URL = './terms.json?ver={{artifactVersion}}';
      window.__TOTAL_TERMS = {{stats.totalTerms}};

      /**
       * FOSS Glossary Landing Page - Client-Side Search & Filter Engine
       *
       * Features:
       * - Real-time search across ALL terms (lazy loaded from terms.json)
       * - Filter by score range (90+, 80-89, etc.)
       * - Sort by date, score, alphabetical
       * - Click tags to filter by category
       * - Responsive design with mobile-friendly controls
       * - Debounced search for performance
       * - Keyboard navigation support
       *
       * No external dependencies - pure vanilla JavaScript
       */

      const SearchEngine = {
        // Terms from the initial DOM (10 recent terms)
        displayedTerms: [],
        // All terms loaded from JSON (lazy loaded on first search)
        allTermsFromJson: null,
        // Current filtered terms to display
        filteredTerms: [],
        // Search and filter state
        searchTerm: '',
        scoreFilters: new Set(),
        tagFilters: new Set(),
        sortBy: 'date-desc',
        debounceTimer: null,
        debounceDelay: 150,
        // Track if we're in search mode (showing results from JSON)
        isSearchMode: false,
        // Loading state
        isLoading: false,

        /**
         * Initialize the search engine
         * Extract initial term data from DOM and setup event listeners
         */
        init() {
          this.extractTermsFromDOM();
          this.setupEventListeners();
          this.setupTagClickHandlers();
          this.filter();
          this.render();
          console.log(
            'ğŸ” Search engine initialized with',
            this.displayedTerms.length,
            'displayed terms'
          );
        },

        /**
         * Extract term data from DOM cards (initial 10 terms)
         * Converts data attributes to searchable objects
         */
        extractTermsFromDOM() {
          const cards = document.querySelectorAll('[data-term]');
          this.displayedTerms = Array.from(cards).map((card, index) => ({
            element: card,
            term: card.dataset.term,
            slug: card.dataset.slug,
            definition: card.dataset.definition,
            humor: card.dataset.humor || '',
            score: parseInt(card.dataset.score),
            tags: (card.dataset.tags || '').split(' ').filter((t) => t.length > 0),
            sortDate: new Date(card.dataset.date || new Date()).getTime(),
            originalIndex: index,
          }));
        },

        /**
         * Lazy load all terms from terms.json
         * Only fetches once, caches result
         */
        async fetchAllTerms() {
          if (this.allTermsFromJson !== null) {
            return this.allTermsFromJson;
          }

          this.isLoading = true;
          this.updateLoadingState();

          try {
            const response = await fetch(window.__TERMS_JSON_URL);
            if (!response.ok) {
              throw new Error('Failed to fetch terms.json');
            }
            const data = await response.json();

            // Convert JSON terms to our internal format
            this.allTermsFromJson = data.terms.map((term, index) => ({
              element: null, // No DOM element for JSON-loaded terms
              term: term.term,
              slug: term.slug,
              definition: term.definition,
              humor: term.humor || '',
              explanation: term.explanation || '',
              score: this.calculateScore(term),
              tags: term.tags || [],
              seeAlso: term.see_also || [],
              controversyLevel: term.controversy_level || '',
              sortDate: Date.now() - index * 1000, // Approximate order
              originalIndex: index,
            }));

            console.log(
              'ğŸ“¥ Loaded',
              this.allTermsFromJson.length,
              'terms from JSON'
            );
            return this.allTermsFromJson;
          } catch (error) {
            console.error('âŒ Error loading terms:', error);
            return [];
          } finally {
            this.isLoading = false;
            this.updateLoadingState();
          }
        },

        /**
         * Calculate score for a term (simplified version)
         */
        calculateScore(term) {
          let score = 0;
          // Base points for term + definition
          if (term.term && term.definition) score += 20;
          // Humor points (1 per 5 chars, max 30)
          if (term.humor) score += Math.min(30, Math.floor(term.humor.length / 5));
          // Explanation points
          if (term.explanation && term.explanation.length > 20) score += 20;
          // Tag points (3 per tag, max 10)
          if (term.tags) score += Math.min(10, term.tags.length * 3);
          // Cross-reference points (5 per ref, max 20)
          if (term.see_also) score += Math.min(20, term.see_also.length * 5);
          return Math.min(100, score);
        },

        /**
         * Update loading indicator
         */
        updateLoadingState() {
          const resultCount = document.getElementById('resultCount');
          if (resultCount && this.isLoading) {
            resultCount.textContent = 'Loading all terms...';
          }
        },

        /**
         * Setup event listeners for search, filters, and sort
         */
        setupEventListeners() {
          const searchInput = document.getElementById('searchInput');
          if (searchInput) {
            searchInput.addEventListener('input', (e) => {
              clearTimeout(this.debounceTimer);
              this.debounceTimer = setTimeout(async () => {
                this.searchTerm = e.target.value.toLowerCase().trim();

                // If user is searching, fetch all terms and enter search mode
                if (this.searchTerm) {
                  await this.fetchAllTerms();
                  this.isSearchMode = true;
                } else {
                  // Clear search - return to showing displayed terms
                  this.isSearchMode = false;
                }

                this.filter();
                this.render();
              }, this.debounceDelay);
            });

            // Clear search on Escape key
            searchInput.addEventListener('keydown', (e) => {
              if (e.key === 'Escape') {
                searchInput.value = '';
                this.searchTerm = '';
                this.isSearchMode = false;
                this.filter();
                this.render();
              }
            });
          }

          // Score filters
          document.querySelectorAll('.score-filter').forEach((checkbox) => {
            checkbox.addEventListener('change', async (e) => {
              if (e.target.checked) {
                this.scoreFilters.add(e.target.value);
              } else {
                this.scoreFilters.delete(e.target.value);
              }

              // If filtering, load all terms
              if (this.scoreFilters.size > 0 || this.tagFilters.size > 0) {
                await this.fetchAllTerms();
                this.isSearchMode = true;
              } else if (!this.searchTerm) {
                this.isSearchMode = false;
              }

              this.filter();
              this.render();
            });
          });

          // Sort select
          const sortSelect = document.getElementById('sortSelect');
          if (sortSelect) {
            sortSelect.addEventListener('change', (e) => {
              this.sortBy = e.target.value;
              this.sort();
              this.render();
            });
          }
        },

        /**
         * Setup click handlers for category tag filtering
         */
        setupTagClickHandlers() {
          document.addEventListener('click', async (e) => {
            const tagElement = e.target.closest('.tag:not(.featured-tag)');
            if (tagElement) {
              const tag = tagElement.dataset.tag;
              if (this.tagFilters.has(tag)) {
                this.tagFilters.delete(tag);
              } else {
                this.tagFilters.add(tag);
              }

              // If filtering, load all terms
              if (this.tagFilters.size > 0 || this.scoreFilters.size > 0) {
                await this.fetchAllTerms();
                this.isSearchMode = true;
              } else if (!this.searchTerm) {
                this.isSearchMode = false;
              }

              this.filter();
              this.render();
            }
          });
        },

        /**
         * Filter terms based on search and filters
         */
        filter() {
          // Determine which terms to filter
          const sourceTerms = this.isSearchMode
            ? this.allTermsFromJson || []
            : this.displayedTerms;

          this.filteredTerms = sourceTerms.filter((term) => {
            // Text search
            if (this.searchTerm) {
              const searchFields = [
                term.term.toLowerCase(),
                term.definition.toLowerCase(),
                term.humor.toLowerCase(),
                (term.explanation || '').toLowerCase(),
                ...term.tags.map((t) => t.toLowerCase()),
              ];
              const matches = searchFields.some((field) =>
                field.includes(this.searchTerm)
              );
              if (!matches) return false;
            }

            // Score filter
            if (this.scoreFilters.size > 0) {
              const scoreInRange = Array.from(this.scoreFilters).some((range) => {
                const [min, max] = range.split('-').map(Number);
                return term.score >= min && term.score <= max;
              });
              if (!scoreInRange) return false;
            }

            // Tag filter
            if (this.tagFilters.size > 0) {
              const hasTag = term.tags.some((tag) => this.tagFilters.has(tag));
              if (!hasTag) return false;
            }

            return true;
          });

          this.sort();
        },

        /**
         * Sort filtered terms
         */
        sort() {
          switch (this.sortBy) {
            case 'date-desc':
              this.filteredTerms.sort((a, b) => b.sortDate - a.sortDate);
              break;
            case 'score-desc':
              this.filteredTerms.sort((a, b) => b.score - a.score);
              break;
            case 'score-asc':
              this.filteredTerms.sort((a, b) => a.score - b.score);
              break;
            case 'alpha-asc':
              this.filteredTerms.sort((a, b) => a.term.localeCompare(b.term));
              break;
          }
        },

        /**
         * Get score color based on score value
         */
        getScoreColor(score) {
          if (score >= 80) return '#00d4e4';
          if (score >= 60) return '#00f0ff';
          return '#ffd93d';
        },

        /**
         * Escape HTML to prevent XSS
         */
        escapeHtml(text) {
          if (!text) return '';
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        },

        /**
         * Create a term card element for dynamically loaded terms
         */
        createTermCard(term) {
          const card = document.createElement('div');
          card.className = 'term-card visible';
          card.dataset.term = term.term;
          card.dataset.slug = term.slug;
          card.dataset.score = term.score;
          card.dataset.tags = term.tags.join(' ');
          card.dataset.definition = term.definition;
          card.dataset.humor = term.humor;

          const scoreColor = this.getScoreColor(term.score);

          let tagsHtml = '';
          if (term.tags.length > 0) {
            tagsHtml = `
              <div class="term-tags">
                ${term.tags.map((tag) => { const escaped = this.escapeHtml(tag); return `<span class="tag" data-tag="${escaped}">${escaped}</span>`; }).join('')}
              </div>
            `;
          }

          let humorHtml = '';
          if (term.humor) {
            humorHtml = `<p class="term-humor">ğŸ˜‚ "${this.escapeHtml(term.humor)}"</p>`;
          }

          card.innerHTML = `
            <div class="term-header">
              <h3>${this.escapeHtml(term.term)}</h3>
              <div class="score-bar-container">
                <div class="score-bar" style="width: ${term.score}%; background-color: ${scoreColor};"></div>
              </div>
              <span class="term-score" style="color: ${scoreColor}">${term.score}</span>
            </div>
            <p class="term-definition">${this.escapeHtml(term.definition)}</p>
            ${humorHtml}
            ${tagsHtml}
          `;

          return card;
        },

        /**
         * Render the current state
         */
        render() {
          const termGrid = document.getElementById('termGrid');
          if (!termGrid) return;

          if (this.isSearchMode) {
            // In search mode: hide all displayed terms, show search results
            this.displayedTerms.forEach((term) => {
              term.element.style.display = 'none';
            });

            // Remove any previously created search result cards
            const existingSearchCards = termGrid.querySelectorAll(
              '.term-card.search-result'
            );
            existingSearchCards.forEach((card) => card.remove());

            // Create and append new cards for search results
            this.filteredTerms.forEach((term) => {
              const card = this.createTermCard(term);
              card.classList.add('search-result');
              termGrid.appendChild(card);
            });
          } else {
            // Not in search mode: show displayed terms, remove search result cards
            const existingSearchCards = termGrid.querySelectorAll(
              '.term-card.search-result'
            );
            existingSearchCards.forEach((card) => card.remove());

            // Reorder and show/hide displayed terms
            this.filteredTerms.forEach((term) => {
              if (term.element) {
                termGrid.appendChild(term.element);
              }
            });

            this.displayedTerms.forEach((term) => {
              const isVisible = this.filteredTerms.includes(term);
              term.element.style.display = isVisible ? 'block' : 'none';
              if (isVisible) {
                term.element.classList.add('visible');
              } else {
                term.element.classList.remove('visible');
              }
            });
          }

          // Update result count
          const resultCount = document.getElementById('resultCount');
          if (resultCount) {
            const count = this.filteredTerms.length;
            const total = window.__TOTAL_TERMS || {{stats.totalTerms}};
            if (this.isSearchMode) {
              resultCount.textContent = `Showing ${count} of ${total} terms (searching all)`;
            } else {
              resultCount.textContent = `Showing ${count} of ${total} terms`;
            }
          }

          // Show/hide empty state
          const emptyState = document.getElementById('emptyState');
          if (emptyState) {
            emptyState.style.display =
              this.filteredTerms.length === 0 ? 'block' : 'none';
          }

          // Update active filters display
          this.updateActiveFiltersDisplay();
        },

        /**
         * Display active filters as removable chips
         */
        updateActiveFiltersDisplay() {
          const container = document.getElementById('activeFilters');
          if (!container) return;

          container.innerHTML = '';

          const allFilters = new Set([...this.scoreFilters, ...this.tagFilters]);
          if (allFilters.size === 0) return;

          allFilters.forEach((filter) => {
            const chip = document.createElement('span');
            chip.className = 'filter-chip';

            let label = filter;
            if (filter.includes('-') && !filter.includes('tag')) {
              const [min, max] = filter.split('-');
              label = `Score ${min}-${max}`;
            }

            const escapedLabel = this.escapeHtml(label);
            const escapedFilter = this.escapeHtml(filter);
            chip.innerHTML = `${escapedLabel} <button class="chip-remove" data-filter="${escapedFilter}">âœ•</button>`;

            chip.querySelector('.chip-remove').addEventListener('click', () => {
              this.scoreFilters.delete(filter);
              this.tagFilters.delete(filter);

              // Check if we should exit search mode
              if (
                !this.searchTerm &&
                this.scoreFilters.size === 0 &&
                this.tagFilters.size === 0
              ) {
                this.isSearchMode = false;
              }

              this.filter();
              this.render();
            });

            container.appendChild(chip);
          });
        },
      };

      /**
       * Animation utilities for entrance animations
       */
      const Animations = {
        init() {
          this.observeElements();
          this.attachAnimationClasses();
        },

        attachAnimationClasses() {
          document.querySelectorAll('[data-animate]').forEach((el) => {
            el.classList.add('animate-on-load');
            const animationType = el.dataset.animate;
            el.classList.add(`animate-${animationType}`);
            if (el.dataset.delay) {
              const delay = parseInt(el.dataset.delay) * 50;
              el.style.animationDelay = `${delay}ms`;
            }
          });
        },

        observeElements() {
          if (!('IntersectionObserver' in window)) return;

          const observer = new IntersectionObserver(
            (entries) => {
              entries.forEach((entry) => {
                if (entry.isIntersecting) {
                  entry.target.classList.add('in-view');
                  observer.unobserve(entry.target);
                }
              });
            },
            { threshold: 0.1 }
          );

          document.querySelectorAll('[data-animate]').forEach((el) => {
            observer.observe(el);
          });
        },
      };

      // Initialize on page load
      document.addEventListener('DOMContentLoaded', () => {
        SearchEngine.init();
        Animations.init();
      });
    </script>
  </body>
</html>